<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Семейное древо</title>

    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-0: #0b1020;
            --bg-1: #101a3a;

            --panel-border: rgba(255, 255, 255, .10);

            --text: #e7eaf3;
            --muted: rgba(231, 234, 243, .72);

            --card: #ffffff;
            --card-text: #0f172a;
            --card-muted: #64748b;

            --male: #2563eb;
            --female: #ef4444;
            --unknown: #94a3b8;

            --link: rgba(226, 232, 240, .26);
            --link-strong: rgba(226, 232, 240, .38);

            --shadow: 0 14px 30px rgba(0, 0, 0, .22);

            --ring: #fb7185;

            --dim: 0.18;
            --dimLinks: 0.12;

            --branch-color: rgba(56, 189, 248, .85);
            /* будет меняться из JS */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            background:
                radial-gradient(1200px 700px at 20% 20%, rgba(99, 102, 241, .20), transparent 60%),
                radial-gradient(1000px 700px at 80% 30%, rgba(34, 211, 238, .16), transparent 55%),
                radial-gradient(900px 700px at 60% 90%, rgba(244, 63, 94, .10), transparent 55%),
                linear-gradient(160deg, var(--bg-1), var(--bg-0));
            color: var(--text);
        }

        .app-container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column
        }

        .app-header {
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(15, 23, 42, .55);
            border-bottom: 1px solid var(--panel-border);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 10;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px
        }

        .logo i {
            width: 34px;
            height: 34px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, .08);
            border: 1px solid rgba(255, 255, 255, .10);
            color: #a5b4fc;
            font-size: 16px;
        }

        .logo h1 {
            font-size: 16px;
            font-weight: 600;
            letter-spacing: .2px
        }

        .logo .sub {
            margin-left: 10px;
            font-size: 12px;
            color: var(--muted);
            font-weight: 500;
            display: none;
        }

        @media(min-width:980px) {
            .logo .sub {
                display: inline
            }
        }

        .controls {
            display: flex;
            gap: 8px
        }

        .ctrl-btn {
            width: 40px;
            height: 40px;
            border-radius: 14px;
            background: rgba(255, 255, 255, .08);
            border: 1px solid rgba(255, 255, 255, .10);
            color: var(--text);
            cursor: pointer;
            box-shadow: 0 6px 16px rgba(0, 0, 0, .12);
            transition: transform .12s ease, background .12s ease, border-color .12s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ctrl-btn:hover {
            background: rgba(255, 255, 255, .12);
            border-color: rgba(255, 255, 255, .16);
            transform: translateY(-1px);
        }

        .ctrl-btn:active {
            transform: translateY(0px) scale(.98);
        }

        .main-content {
            flex: 1;
            position: relative
        }

        #tree {
            width: 100%;
            height: 100%
        }

        .link {
            fill: none;
            stroke: var(--link);
            stroke-width: 1.6;
            stroke-linecap: round;
            transition: opacity .15s ease, stroke .15s ease;
        }

        .node {
            cursor: default
        }

        .card-shadow {
            filter: drop-shadow(0 12px 20px rgba(0, 0, 0, .18));
        }

        .person-outer {
            fill: var(--card);
            stroke-width: 1.6;
            transition: transform .12s ease, filter .12s ease, stroke-width .12s ease, opacity .15s ease;
        }

        .person-outer.m {
            stroke: color-mix(in srgb, var(--male) 65%, white)
        }

        .person-outer.f {
            stroke: color-mix(in srgb, var(--female) 65%, white)
        }

        .person-outer.u {
            stroke: rgba(148, 163, 184, .9)
        }

        .node:hover .person-outer {
            filter: drop-shadow(0 14px 22px rgba(0, 0, 0, .22));
            transform: translateY(-1px);
        }

        .node.selected .person-outer {
            stroke: #f59e0b !important;
            stroke-width: 3 !important;
        }

        .dimmed {
            opacity: var(--dim);
        }

        .dimmed-link {
            opacity: var(--dimLinks);
        }

        /* Highlight branch */
        .in-branch .person-outer {
            filter: drop-shadow(0 18px 26px color-mix(in srgb, var(--branch-color) 35%, transparent));
        }

        .in-branch-link {
            stroke: var(--branch-color) !important;
            opacity: .78 !important;
            stroke-width: 2.1 !important;
        }

        /* Right panel */
        .info-panel {
            position: fixed;
            top: 76px;
            right: 0;
            width: 360px;
            height: calc(100vh - 132px);
            background: rgba(255, 255, 255, .92);
            color: #0f172a;
            border-radius: 18px 0 0 18px;
            transform: translateX(calc(100% - 54px));
            transition: .25s;
            z-index: 100;
            box-shadow: var(--shadow);
            overflow: hidden;
            border: 1px solid rgba(15, 23, 42, .06);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .info-panel.open {
            transform: translateX(0)
        }

        .info-tab {
            position: absolute;
            left: -54px;
            top: 110px;
            width: 54px;
            height: 150px;
            background: rgba(15, 23, 42, .88);
            border: 1px solid rgba(255, 255, 255, .10);
            border-right: none;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 16px 0 0 16px;
            box-shadow: 0 12px 24px rgba(0, 0, 0, .22);
        }

        .info-header {
            background: rgba(15, 23, 42, .92);
            color: #fff;
            padding: 12px 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .close-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 22px;
            cursor: pointer;
            line-height: 1
        }

        .info-content {
            padding: 14px 14px 18px;
            overflow: auto;
            height: calc(100% - 48px);
            font-size: 13px;
            line-height: 1.45;
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 7px 10px;
            border-radius: 999px;
            background: rgba(15, 23, 42, .05);
            border: 1px solid rgba(15, 23, 42, .08);
            font-size: 12px;
            color: rgba(15, 23, 42, .78);
            margin-top: 10px;
        }

        .hint {
            margin-top: 12px;
            font-size: 12px;
            color: rgba(15, 23, 42, .60);
        }

        @media(max-width:768px) {
            .info-panel {
                width: 92vw;
                top: auto;
                bottom: 16px;
                height: min(70vh, 520px)
            }
        }
    </style>
</head>

<body>
    <div class="app-container">

        <header class="app-header">
            <div class="logo">
                <i class="fa-solid fa-tree"></i>
                <h1>Семейное древо <span class="sub">— интерактивная генеалогия</span></h1>
            </div>
            <div class="controls">
                <button id="zoom-in" class="ctrl-btn" title="Увеличить"><i class="fa-solid fa-plus"></i></button>
                <button id="zoom-out" class="ctrl-btn" title="Уменьшить"><i class="fa-solid fa-minus"></i></button>
                <button id="reset-view" class="ctrl-btn" title="Сброс"><i
                        class="fa-solid fa-arrows-rotate"></i></button>
            </div>
        </header>

        <div class="main-content">
            <div id="tree"></div>
        </div>

        <div id="info-panel" class="info-panel">
            <div id="info-tab" class="info-tab" title="Информация"><i class="fa-solid fa-id-card"></i></div>
            <div class="info-header">
                <div style="font-weight:600">Карточка</div>
                <button id="close-info" class="close-btn" title="Свернуть">&times;</button>
            </div>
            <div id="person-info" class="info-content">Выберите человека</div>
        </div>

    </div>

    <script>
        /* ================= STATE ================= */
        let data = null, zoom = null;
        let rootId = null;

        let currentId = null;   // выбранный человек для панели справа
        let focusId = null;     // фокус-ветвь (toggle)

        let didInitialFit = false;

        /* animation state */
        const prevPos = new Map();   // key -> {x,y}
        const prevLinkD = new Map(); // key -> d string

        /* ================= CONFIG ================= */
        const CARD_W = 230;
        const CARD_H = 90;
        const COUPLE_GAP = 8;
        const COUPLE_TOTAL_H = CARD_H * 2 + COUPLE_GAP;

        const NODE_X = COUPLE_TOTAL_H + 14;
        const NODE_Y = 250;
        const SEP_SIBLINGS = 1.0;
        const SEP_OTHER = 1.12;

        const ANIM_MS = 420; // morph duration

        // ❤️ icon + color
        const MARRIAGE_ICON = 'fa-heart';
        const MARRIAGE_ICON_COLOR = getCssVar('--ring');

        /* ================= INIT ================= */
        fetch('./3.ged')
            .then(r => r.text())
            .then(t => {
                data = parseGedcom(t);
                rootId = findRoot();
                render(true);
                setupUI();
            })
            .catch(e => console.error('GED load error', e));

        /* ================= GEDCOM ================= */
        function parseGedcom(t) {
            const people = {}, fams = {};
            let cur = null, evt = null;

            t.split(/\r?\n/).forEach(l => {
                const m = l.match(/^(\d+)\s+(@?[^ ]+@?)\s*(.*)$/);
                if (!m) return;

                const lvl = +m[1];
                const tag = m[2].replace(/@/g, '');
                const val = m[3];

                if (lvl === 0) {
                    evt = null;
                    if (val.includes('INDI')) {
                        cur = { t: 'P', id: tag };
                        people[tag] = { id: tag, name: '', sex: '', birth: '', death: '', FAMS: [], FAMC: [] };
                    } else if (val.includes('FAM')) {
                        cur = { t: 'F', id: tag };
                        fams[tag] = { id: tag, husb: null, wife: null, chil: [], marriage: '' };
                    } else cur = null;
                    return;
                }

                if (!cur) return;

                if (lvl === 1) {
                    evt = null;
                    if (tag === 'BIRT') evt = 'birth';
                    if (tag === 'DEAT') evt = 'death';
                    if (tag === 'MARR') evt = 'marriage';
                }

                if (cur.t === 'P') {
                    const p = people[cur.id];
                    if (tag === 'NAME') p.name = val.replace(/\//g, '').trim();
                    if (tag === 'SEX') p.sex = val;
                    if (tag === 'FAMS') p.FAMS.push(val.replace(/@/g, ''));
                    if (tag === 'FAMC') p.FAMC.push(val.replace(/@/g, ''));
                    if (lvl === 2 && evt && tag === 'DATE') p[evt] = val.trim();
                }

                if (cur.t === 'F') {
                    const f = fams[cur.id];
                    if (tag === 'HUSB') f.husb = val.replace(/@/g, '');
                    if (tag === 'WIFE') f.wife = val.replace(/@/g, '');
                    if (tag === 'CHIL') f.chil.push(val.replace(/@/g, ''));
                    if (lvl === 2 && evt && tag === 'DATE') f[evt] = val.trim();
                }
            });

            return { people, fams };
        }

        function findRoot() {
            const ids = Object.keys(data.people);
            return ids.find(id => !(data.people[id].FAMC || []).length) || ids[0];
        }

        /* ================= BUILD DISPLAY TREE (plain objects) ================= */
        function buildDisplayTree(personId, seen = new Set()) {
            if (!personId || seen.has(personId)) return null;
            seen.add(personId);

            const p = data.people[personId];
            if (!p) return null;

            const fams = (p.FAMS || []).map(fid => data.fams[fid]).filter(Boolean);

            const mainFam = fams.find(f => {
                const spouse = (f.husb === personId) ? f.wife : f.husb;
                return !!spouse || (f.chil && f.chil.length);
            });

            if (mainFam) {
                const spouseId = (mainFam.husb === personId) ? mainFam.wife : mainFam.husb;
                const node = {
                    type: 'couple',
                    primaryId: personId,
                    spouseId: spouseId || null,
                    marriage: mainFam.marriage || '',
                    children: []
                };

                (mainFam.chil || []).forEach(cid => {
                    const ch = buildDisplayTree(cid, new Set(seen));
                    if (ch) node.children.push(ch);
                });

                if (!node.children.length) delete node.children;
                return node;
            }

            return {
                type: 'person',
                id: personId,
                name: p.name || 'Без имени',
                sex: p.sex || '',
                b: p.birth || '',
                d: p.death || '',
            };
        }

        /* ================= Identity helpers ================= */
        function dataPrimaryId(node) {
            if (!node) return null;
            if (node.type === 'couple') return node.primaryId;
            if (node.type === 'person') return node.id;
            return null;
        }

        /* ================= Branch computation ================= */
        function computeBranchIds(rootH, targetPersonId) {
            let targetNode = null;
            rootH.each(d => {
                const pid = (d.data.type === 'couple') ? d.data.primaryId : (d.data.type === 'person') ? d.data.id : null;
                if (pid === targetPersonId) targetNode = d;
            });
            if (!targetNode) return new Set();

            const ids = new Set();
            targetNode.ancestors().forEach(d => {
                const pid = (d.data.type === 'couple') ? d.data.primaryId : (d.data.type === 'person') ? d.data.id : null;
                if (pid) ids.add(pid);
            });
            targetNode.descendants().forEach(d => {
                const pid = (d.data.type === 'couple') ? d.data.primaryId : (d.data.type === 'person') ? d.data.id : null;
                if (pid) ids.add(pid);
            });
            return ids;
        }

        /* --- SIBLINGS: add brothers/sisters of selected person + their descendants --- */
        function getSiblingIds(personId) {
            const p = data.people[personId];
            if (!p) return [];
            const famc = (p.FAMC || [])[0]; // берем первую родительскую семью
            if (!famc) return [];
            const fam = data.fams[famc];
            if (!fam) return [];
            const kids = fam.chil || [];
            return kids.filter(id => id && id !== personId);
        }

        function expandIdsWithSiblings(fullRoot, baseIds, targetPersonId) {
            const out = new Set(baseIds);
            const sibs = getSiblingIds(targetPersonId);

            if (!sibs.length) return out;

            // для каждого sibling добавим его и всех его потомков в дереве
            for (const sid of sibs) {
                out.add(sid);
                let sibNode = null;
                fullRoot.each(d => {
                    const pid = (d.data.type === 'couple') ? d.data.primaryId : (d.data.type === 'person') ? d.data.id : null;
                    if (pid === sid) sibNode = d;
                });
                if (sibNode) {
                    sibNode.descendants().forEach(d => {
                        const pid = (d.data.type === 'couple') ? d.data.primaryId : (d.data.type === 'person') ? d.data.id : null;
                        if (pid) out.add(pid);
                    });
                }
            }
            return out;
        }

        /* ================= Prune plain data by ids ================= */
        function pruneDataByIds(node, keepIds) {
            if (!node) return null;

            const selfId = dataPrimaryId(node);
            const selfKept = selfId ? keepIds.has(selfId) : false;

            const kids = (node.children || [])
                .map(ch => pruneDataByIds(ch, keepIds))
                .filter(Boolean);

            if (selfKept || kids.length) {
                const copy = { ...node };
                if (kids.length) copy.children = kids;
                else delete copy.children;
                return copy;
            }
            return null;
        }

        /* ================= Resolve focus target (if click spouse) ================= */
        function resolveFocusTarget(rootH, clickedId) {
            // 1) as primary/id
            let found = null;
            rootH.each(d => {
                const pid = (d.data.type === 'couple') ? d.data.primaryId : (d.data.type === 'person') ? d.data.id : null;
                if (pid === clickedId) found = pid;
            });
            if (found) return found;

            // 2) as spouseId -> focus on couple.primaryId
            let couplePrimary = null;
            rootH.each(d => {
                if (d.data.type === 'couple' && d.data.spouseId === clickedId) {
                    couplePrimary = d.data.primaryId;
                }
            });
            return couplePrimary || clickedId;
        }

        /* ================= Branch color ================= */
        function setBranchColorFromId(personId) {
            const hue = hashHue(String(personId || 'x'));
            // nice neon-ish but classy: use HSL
            const css = `hsla(${hue}, 92%, 62%, .88)`;
            document.documentElement.style.setProperty('--branch-color', css);
        }
        function hashHue(s) {
            let h = 0;
            for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) >>> 0;
            return h % 360;
        }

        /* ================= RENDER ================= */
        function render(forceFit = false) {
            const baseData = buildDisplayTree(rootId);
            drawTree(baseData, forceFit);
        }

        function drawTree(baseData, forceFit) {
            d3.select('#tree').selectAll('*').remove();

            const container = document.getElementById('tree');
            const w = container.clientWidth;
            const h = container.clientHeight;

            const svg = d3.select('#tree').append('svg').attr('width', w).attr('height', h);
            const g = svg.append('g');

            zoom = d3.zoom().scaleExtent([0.15, 3]).on('zoom', e => g.attr('transform', e.transform));
            svg.call(zoom);

            const layout = d3.tree()
                .nodeSize([NODE_X, NODE_Y])
                .separation((a, b) => a.parent === b.parent ? SEP_SIBLINGS : SEP_OTHER);

            // Full hierarchy for branch computation
            const fullRoot = d3.hierarchy(baseData);
            layout(fullRoot);

            const highlightCandidate = focusId || currentId;
            let branchIds = new Set();

            if (highlightCandidate) {
                const resolved = resolveFocusTarget(fullRoot, highlightCandidate);

                // set branch color from resolved target
                setBranchColorFromId(resolved);

                // base branch: ancestors + descendants
                branchIds = computeBranchIds(fullRoot, resolved);

                // add siblings of resolved person (and their descendants)
                branchIds = expandIdsWithSiblings(fullRoot, branchIds, resolved);
            }

            // render data (prune only in focus)
            let renderData = baseData;
            if (focusId && branchIds.size) {
                renderData = pruneDataByIds(baseData, branchIds) || baseData;
            }

            // Layout on render hierarchy
            const renderRoot = d3.hierarchy(renderData);
            layout(renderRoot);

            // prepare animations: build current position map and keys
            const nodeKey = (d) => {
                const pid = (d.data.type === 'couple') ? d.data.primaryId : (d.data.type === 'person') ? d.data.id : '';
                // distinguish couple vs single if ever needed:
                return `${d.data.type}:${pid}`;
            };

            // Links
            const links = renderRoot.links();
            const linkGen = d3.linkHorizontal().x(p => p.y).y(p => p.x);

            function linkKey(l) {
                const a = (l.source.data.type === 'couple') ? l.source.data.primaryId : l.source.data.id;
                const b = (l.target.data.type === 'couple') ? l.target.data.primaryId : l.target.data.id;
                return `${a}=>${b}`;
            }

            const linkSel = g.selectAll('.link')
                .data(links, linkKey)
                .enter().append('path')
                .attr('class', 'link')
                .attr('d', l => {
                    const k = linkKey(l);
                    const prev = prevLinkD.get(k);
                    const cur = linkGen({
                        source: getLinkSourceAnchor(l.source),
                        target: getLinkTargetAnchor(l.target)
                    });
                    return prev || cur;
                })
                .style('opacity', 0);

            // Nodes
            const nodeSel = g.selectAll('.node')
                .data(renderRoot.descendants(), nodeKey)
                .enter().append('g')
                .attr('class', d => `node ${d.data.type}`)
                .attr('transform', d => {
                    const k = nodeKey(d);
                    const prev = prevPos.get(k);
                    if (prev) return `translate(${prev.y},${prev.x})`;
                    return `translate(${d.y},${d.x})`;
                })
                .style('opacity', 0)
                .each(function (d) { drawNode(d3.select(this), d.data, fullRoot, branchIds); });

            // Apply dimming/highlight only in full mode
            if (!focusId && branchIds.size) {
                nodeSel.each(function (d) {
                    const pid = (d.data.type === 'couple') ? d.data.primaryId : (d.data.type === 'person') ? d.data.id : null;
                    if (pid && !branchIds.has(pid)) {
                        d3.select(this).classed('dimmed', true);
                    } else {
                        d3.select(this).classed('in-branch', true);
                    }
                });

                linkSel.each(function (l) {
                    const a = (l.source.data.type === 'couple') ? l.source.data.primaryId : l.source.data.id;
                    const b = (l.target.data.type === 'couple') ? l.target.data.primaryId : l.target.data.id;
                    if (!(branchIds.has(a) && branchIds.has(b))) {
                        d3.select(this).classed('dimmed-link', true);
                    } else {
                        d3.select(this).classed('in-branch-link', true);
                    }
                });
            } else if (focusId && branchIds.size) {
                // In focus mode everything is "branch" by definition: emphasize links a bit
                linkSel.classed('in-branch-link', true);
                nodeSel.classed('in-branch', true);
            }

            // Animate to new positions
            nodeSel.transition()
                .duration(ANIM_MS)
                .ease(d3.easeCubicOut)
                .attr('transform', d => `translate(${d.y},${d.x})`)
                .style('opacity', 1);

            linkSel.transition()
                .duration(ANIM_MS)
                .ease(d3.easeCubicOut)
                .attr('d', l => linkGen({
                    source: getLinkSourceAnchor(l.source),
                    target: getLinkTargetAnchor(l.target)
                }))
                .style('opacity', 1);

            // Store current positions for next morph
            renderRoot.descendants().forEach(d => {
                prevPos.set(nodeKey(d), { x: d.x, y: d.y });
            });
            links.forEach(l => {
                const k = linkKey(l);
                const cur = linkGen({
                    source: getLinkSourceAnchor(l.source),
                    target: getLinkTargetAnchor(l.target)
                });
                prevLinkD.set(k, cur);
            });

            // Fit behavior:
            if (forceFit || !didInitialFit || focusId) {
                // slightly delay fit so animation feels nice
                setTimeout(() => fit(svg, g, w, h), 0);
                didInitialFit = true;
            }
        }

        /* ================= LINK ANCHORS ================= */
        function getLinkSourceAnchor(node) {
            if (!node) return { x: 0, y: 0 };
            const y = node.y + (CARD_W / 2);
            return { x: node.x, y };
        }
        function getLinkTargetAnchor(node) {
            if (!node) return { x: 0, y: 0 };
            const d = node.data;
            const y = node.y - (CARD_W / 2);

            if (d.type === 'couple') {
                const half = (CARD_H + COUPLE_GAP) / 2;
                const topCardCenterX = node.x - half;
                return { x: topCardCenterX, y };
            }
            return { x: node.x, y };
        }

        /* ================= NODE DRAW ================= */
        function drawNode(g, n, fullRoot, branchIds) {
            if (n.type === 'person') {
                const p = data.people[n.id] || { name: n.name, sex: n.sex, birth: n.b, death: n.d };
                drawPersonCard(g, {
                    id: n.id,
                    name: p.name || n.name,
                    sex: p.sex || n.sex,
                    b: p.birth || n.b,
                    d: p.death || n.d
                }, 0, fullRoot);
                return;
            }

            if (n.type === 'couple') {
                const primary = data.people[n.primaryId];
                const spouse = n.spouseId ? data.people[n.spouseId] : null;
                const half = (CARD_H + COUPLE_GAP) / 2;

                drawPersonCard(g, {
                    id: n.primaryId,
                    name: primary?.name || 'Без имени',
                    sex: primary?.sex || '',
                    b: primary?.birth || '',
                    d: primary?.death || ''
                }, -half, fullRoot);

                if (spouse) {
                    drawPersonCard(g, {
                        id: n.spouseId,
                        name: spouse?.name || 'Без имени',
                        sex: spouse?.sex || '',
                        b: spouse?.birth || '',
                        d: spouse?.death || ''
                    }, +half, fullRoot);
                }

                // connector between spouses
                g.append('path')
                    .attr('d', `M 0 ${-half + CARD_H / 2} L 0 ${+half - CARD_H / 2}`)
                    .attr('fill', 'none')
                    .attr('stroke', getCssVar('--link-strong'))
                    .attr('stroke-width', 1.4);

                // marriage badge
                const marriage = formatGedcomDate(n.marriage);
                const W = marriage ? 200 : 56;
                const H = 32;

                g.append('foreignObject')
                    .attr('x', -W / 2).attr('y', -H / 2)
                    .attr('width', W).attr('height', H)
                    .style('pointer-events', 'none')
                    .append('xhtml:div')
                    .style('width', '100%')
                    .style('height', '100%')
                    .style('display', 'flex')
                    .style('align-items', 'center')
                    .style('justify-content', 'center')
                    .html(`
        <div style="
          display:inline-flex;align-items:center;gap:${marriage ? 8 : 0}px;
          padding:5px 12px;border-radius:999px;
          background:rgba(255,255,255,.92);
          border:1px solid rgba(15,23,42,.08);
          box-shadow: 0 10px 22px rgba(0,0,0,.12);
          font-size:11px;color:rgba(15,23,42,.82);
          font-weight:600;
        ">
          <i class="fa-solid ${escapeHtml(MARRIAGE_ICON)}" style="font-size:16px;color:${escapeHtml(MARRIAGE_ICON_COLOR)}"></i>
          ${marriage ? `<span>${escapeHtml(marriage)}</span>` : ``}
        </div>
      `);

                // ✅ CHILDREN CHIP (кол-во детей)
                const kidsCount = (n.children && n.children.length) ? n.children.length : 0;
                if (kidsCount > 0) {
                    const chipW = 62, chipH = 26;
                    // разместим в правом верхнем углу "потомка" (верхняя карточка)
                    const chipX = (CARD_W / 2) - (chipW / 2) - 10;
                    const chipY = (-half - CARD_H / 2) + 10;

                    g.append('foreignObject')
                        .attr('x', chipX)
                        .attr('y', chipY)
                        .attr('width', chipW)
                        .attr('height', chipH)
                        .style('pointer-events', 'none')
                        .append('xhtml:div')
                        .style('width', '100%')
                        .style('height', '100%')
                        .style('display', 'flex')
                        .style('align-items', 'center')
                        .style('justify-content', 'center')
                        .html(`
          <div style="
            width:100%;height:100%;
            display:flex;align-items:center;justify-content:center;gap:7px;
            border-radius:999px;
            background:rgba(15,23,42,.06);
            border:1px solid rgba(15,23,42,.10);
            color:rgba(15,23,42,.78);
            font-size:11px;font-weight:600;
          ">
            <i class="fa-solid fa-children" style="font-size:12px;"></i>
            <span>${kidsCount}</span>
          </div>
        `);
                }

                return;
            }
        }

        function drawPersonCard(g, p, yOffset, fullRoot) {
            const cls = p.sex === 'M' ? 'm' : p.sex === 'F' ? 'f' : 'u';

            const group = g.append('g')
                .attr('transform', `translate(0,${yOffset})`)
                .style('cursor', 'pointer')
                .on('click', (ev) => { ev.stopPropagation(); onPersonClick(p.id, fullRoot); });

            group.append('rect')
                .attr('class', 'person-outer card-shadow ' + cls)
                .attr('x', -CARD_W / 2).attr('y', -CARD_H / 2)
                .attr('width', CARD_W).attr('height', CARD_H)
                .attr('rx', 18);

            const lines = splitName3(p.name);
            const text = group.append('text')
                .attr('text-anchor', 'middle')
                .attr('y', -20)
                .style('font-weight', '600')
                .style('font-size', '12.5px')
                .style('fill', getCssVar('--card-text'));

            lines.forEach((ln, idx) => {
                text.append('tspan')
                    .attr('x', 0)
                    .attr('dy', idx === 0 ? 0 : 14)
                    .text(shorten(ln, 30));
            });

            const life = formatLifeLine(p);
            if (life) {
                group.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('y', 34)
                    .style('font-size', '11px')
                    .style('font-weight', '500')
                    .style('fill', getCssVar('--card-muted'))
                    .text(life);
            }

            if (p.id === currentId) {
                group.classed('selected', true);
            }
        }

        /* ================= CLICK LOGIC ================= */
        function onPersonClick(clickedId, fullRoot) {
            // update info always
            selectPerson(clickedId, false);

            // toggle focus
            const resolved = resolveFocusTarget(fullRoot, clickedId);

            if (focusId === resolved) {
                focusId = null;
                render(true);
            } else {
                focusId = resolved;
                render(true);
            }
        }

        /* ================= INFO PANEL ================= */
        function selectPerson(id, doRerender = true) {
            currentId = id;
            const p = data.people[id];

            const b = formatGedcomDate(p?.birth || '');
            const d = formatGedcomDate(p?.death || '');
            const sex = (p?.sex === 'M') ? 'Мужчина' : (p?.sex === 'F') ? 'Женщина' : '—';

            const sibs = getSiblingIds(id);
            const sibText = sibs.length ? `${sibs.length}` : '0';

            document.getElementById('person-info').innerHTML = `
    <div style="font-weight:700;font-size:16px;color:#0f172a">${escapeHtml(p?.name || '')}</div>
    <div class="pill"><i class="fa-solid fa-user"></i> <span>${escapeHtml(sex)}</span></div>
    <div class="pill"><i class="fa-solid fa-cake-candles"></i> <span>${escapeHtml(b || '—')}</span></div>
    <div class="pill"><i class="fa-solid fa-skull"></i> <span>${escapeHtml(d || '—')}</span></div>
    <div class="pill"><i class="fa-solid fa-people-group"></i> <span>Братья/сёстры: ${escapeHtml(sibText)}</span></div>

    <div class="hint">
      <b>Клик по человеку</b> — фокус на ветвь + братья/сёстры.<br/>
      <b>Повторный клик</b> — вернуть полное дерево.
    </div>
  `;

            if (doRerender) render(false);
        }

        /* ================= FORMATTING ================= */
        function splitName3(full) {
            const s = String(full || '').trim().replace(/\s+/g, ' ');
            if (!s) return ['Без имени'];
            const t = s.split(' ');
            if (t.length >= 3) {
                const first = t[0];
                const patronymic = t[1];
                const last = t.slice(2).join(' ');
                return [first, patronymic, last];
            }
            if (t.length === 2) return [t[0], t[1]];
            return [t[0]];
        }

        function formatGedcomDate(raw) {
            const s = String(raw || '').trim().toUpperCase();
            if (!s) return '';

            const approx = s.startsWith('ABT ') || s.startsWith('EST ') || s.startsWith('CAL ');
            const before = s.startsWith('BEF ');
            const after = s.startsWith('AFT ');

            let x = s.replace(/^ABT\s+/, '')
                .replace(/^EST\s+/, '')
                .replace(/^CAL\s+/, '')
                .replace(/^BEF\s+/, '')
                .replace(/^AFT\s+/, '')
                .trim();

            if (/^\d{4}$/.test(x)) {
                if (approx) return `≈${x}`;
                if (before) return `<${x}`;
                if (after) return `>${x}`;
                return x;
            }

            const months = {
                JAN: '01', FEB: '02', MAR: '03', APR: '04', MAY: '05', JUN: '06',
                JUL: '07', AUG: '08', SEP: '09', OCT: '10', NOV: '11', DEC: '12'
            };

            const parts = x.split(/\s+/);
            if (parts.length === 3) {
                const dd = pad2(parts[0]);
                const mm = months[parts[1]] || '';
                const yyyy = parts[2];
                if (mm && /^\d{4}$/.test(yyyy)) {
                    const out = `${dd}.${mm}.${yyyy}`;
                    if (approx) return `≈${out}`;
                    if (before) return `<${out}`;
                    if (after) return `>${out}`;
                    return out;
                }
            }
            if (parts.length === 2) {
                const mm = months[parts[0]] || '';
                const yyyy = parts[1];
                if (mm && /^\d{4}$/.test(yyyy)) {
                    const out = `${mm}.${yyyy}`;
                    if (approx) return `≈${out}`;
                    if (before) return `<${out}`;
                    if (after) return `>${out}`;
                    return out;
                }
            }
            return raw.trim();
        }

        function pad2(v) {
            const n = String(v || '').replace(/\D/g, '');
            if (!n) return '00';
            return n.length === 1 ? `0${n}` : n.slice(0, 2);
        }

        function formatLifeLine(p) {
            const b = formatGedcomDate(p?.b || '');
            const d = formatGedcomDate(p?.d || '');
            if (b && d) return `${b} — ${d}`;
            if (b) return b;
            if (d) return d;
            return '';
        }

        /* ================= UI / FIT / HELPERS ================= */
        function fit(svg, g, w, h) {
            const b = g.node().getBBox();
            const pad = 120;
            const s = Math.min(0.95, (w - pad) / b.width, (h - pad) / b.height);
            const tx = w / 2 - (b.x + b.width / 2) * s;
            const ty = h / 2 - (b.y + b.height / 2) * s;
            svg.call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(s));
        }

        function setupUI() {
            document.getElementById('zoom-in').onclick = () => d3.select('svg').transition().call(zoom.scaleBy, 1.2);
            document.getElementById('zoom-out').onclick = () => d3.select('svg').transition().call(zoom.scaleBy, 0.85);
            document.getElementById('reset-view').onclick = () => {
                focusId = null;
                didInitialFit = false;
                render(true);
            };

            document.getElementById('info-tab').onclick = () => document.getElementById('info-panel').classList.toggle('open');
            document.getElementById('close-info').onclick = () => document.getElementById('info-panel').classList.remove('open');

            window.addEventListener('resize', () => {
                didInitialFit = false;
                render(true);
            });
        }

        function escapeHtml(s) {
            return String(s || '')
                .replaceAll('&', '&amp;')
                .replaceAll('<', '&lt;')
                .replaceAll('>', '&gt;')
                .replaceAll('"', '&quot;')
                .replaceAll("'", "&#039;");
        }

        function shorten(s, n) {
            s = String(s || '');
            return s.length > n ? s.slice(0, n - 1) + '…' : s;
        }

        function getCssVar(name) {
            return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        }
    </script>
</body>

</html>